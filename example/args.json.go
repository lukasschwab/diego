// Code generated by diego; DO NOT EDIT.

package main

import (
	"errors"
	"flag"
	"fmt"

	"github.com/lukasschwab/diego/pkg/env"
)

// LukasVars generated from ./args.json.
type LukasVars struct {
	// --color: enable ANSI colors in CLI output
	Color bool `json:"color,omitempty"`
	// --verbose: enable verbose logging
	Verbose bool `json:"verbose,omitempty"`
	// --file: path of file to process
	File string `json:"file,omitempty"`
	// --workers: number of workers to use in parallel
	Workers int `json:"workers,omitempty"`
	// --read-only: do not write output to file
	ReadOnly bool `json:"read-only,omitempty"`
}

// Parse initializes the LukasVars from command-line and environment
// variables. Typically args should be os.Args[1:]; do not include the
// executable name.
func (base *LukasVars) Parse(args []string) error {
	return errors.Join(
		base.foldEnv(),
		base.foldArgs(args),
	)
}

func (base *LukasVars) foldEnv() error {
	var err error
	err = errors.Join(err, env.LookupBool(&base.Color, "LUKAS_COLOR"))
	err = errors.Join(err, env.LookupBool(&base.Verbose, "LUKAS_VERBOSE"))
	env.LookupString(&base.File, "LUKAS_FILE")
	err = errors.Join(err, env.LookupInt(&base.Workers, "LUKAS_WORKERS"))
	err = errors.Join(err, env.LookupBool(&base.ReadOnly, "LUKAS_READ_ONLY"))
	return err
}

func (base *LukasVars) foldArgs(args []string) error {
	fs := flag.NewFlagSet("LukasVars", flag.ContinueOnError)
	fs.BoolVar(&base.Color, "color", base.Color, "enable ANSI colors in CLI output")
	fs.BoolVar(&base.Verbose, "verbose", base.Verbose, "enable verbose logging")
	fs.StringVar(&base.File, "file", base.File, "path of file to process")
	fs.IntVar(&base.Workers, "workers", base.Workers, "number of workers to use in parallel")
	fs.BoolVar(&base.ReadOnly, "read-only", base.ReadOnly, "do not write output to file")
	if err := fs.Parse(args); err != nil {
		return fmt.Errorf("failed to parse command line args: %w", err)
	}
	return nil
}
