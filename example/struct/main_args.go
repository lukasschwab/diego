// Code generated by diego; DO NOT EDIT.

package main

import (
	"errors"
	"flag"
	"fmt"
	"os"
	"strconv"
	"strings"
)

// Parse initializes the ExampleVars from command-line and environment
// variables. Typically args should be os.Args[1:]; do not include the
// executable name.
func (base *ExampleVars) Parse(args []string) error {
	return errors.Join(
		base.foldEnv(),
		base.foldArgs(args),
	)
}

func (base *ExampleVars) foldEnv() error {
	var err error
	err = errors.Join(err, lookupBool(&base.Color, "EXAMPLE_COLOR"))
	err = errors.Join(err, lookupBool(&base.Verbose, "EXAMPLE_VERBOSE"))
	lookupString(&base.File, "EXAMPLE_FILE")
	err = errors.Join(err, lookupInt(&base.Workers, "EXAMPLE_WORKERS"))
	err = errors.Join(err, lookupBool(&base.ReadOnly, "EXAMPLE_READ_ONLY"))
	return err
}

func (base *ExampleVars) foldArgs(args []string) error {
	fs := flag.NewFlagSet("EXAMPLE", flag.ExitOnError)
	fs.BoolVar(&base.Color, "color", base.Color, "enable ANSI colors in CLI output [EXAMPLE_COLOR]")
	fs.BoolVar(&base.Verbose, "verbose", base.Verbose, "enable verbose logging [EXAMPLE_VERBOSE]")
	fs.StringVar(&base.File, "file", base.File, "path of file to process [EXAMPLE_FILE]")
	fs.IntVar(&base.Workers, "workers", base.Workers, "number of workers to use in parallel [EXAMPLE_WORKERS]")
	fs.BoolVar(&base.ReadOnly, "read-only", base.ReadOnly, "do not write output to file [EXAMPLE_READ_ONLY]")
	if err := fs.Parse(args); err != nil {
		return fmt.Errorf("failed to parse command line args: %w", err)
	}
	return nil
}

// lookupString in environment; write to target if it's set.
func lookupString(target *string, name string) {
	read, ok := os.LookupEnv(name)
	if ok {
		*target = read
	}
}

// lookupInt in environment; write to target if it's set and parseable as a
// decimal int.
func lookupInt(target *int, name string) error {
	raw, ok := os.LookupEnv(name)
	if !ok {
		return nil
	}
	parsed, err := strconv.Atoi(raw)
	if err != nil {
		return fmt.Errorf("error parsing int environment variable '%s': %w", name, err)
	}
	*target = parsed
	return nil
}

// lookupBool in environment; write to target if it's set.
func lookupBool(target *bool, name string) error {
	raw, ok := os.LookupEnv(name)
	if !ok {
		return nil
	}
	truthiness := raw != "" && strings.ToLower(raw) != "false"
	*target = truthiness
	return nil
}
