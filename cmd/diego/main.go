package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
	"text/template"

	"github.com/lukasschwab/diego/internal/diego"
	"github.com/tailscale/hujson"
)

func main() {
	if len(os.Args) != 2 {
		log.Fatalf("Usage: %s <input.json>", os.Args[0])
	}
	source := os.Args[1]

	d := new(diego.Schema)
	jsonBytes, err := os.ReadFile(source)
	if err != nil {
		log.Fatalf("error reading source file: %v", err)
	}
	standardized, err := hujson.Standardize(jsonBytes)
	if err != nil {
		log.Fatalf("error standardizing source JSON: %v", err)
	}
	if err := json.Unmarshal(standardized, d); err != nil {
		log.Fatalf("error unmarshaling source JSON: %v", err)
	}

	tmpl, err := template.New("diego").Parse(diego.Template)
	if err != nil {
		log.Fatalf("error parsing template: %v", err)
	}

	templateData := toTemplate(d, source)
	var generated bytes.Buffer
	if err := tmpl.Execute(&generated, templateData); err != nil {
		log.Fatalf("error executing template: %v", err)
	}

	formatted, err := format.Source(generated.Bytes())
	if err != nil {
		log.Fatalf("error formatting generated code: %v\n%s", err, generated.String())
	}

	dest := source + ".go"
	if err := os.WriteFile(dest, formatted, 0644); err != nil {
		log.Fatalf("error writing generated code to %s: %v", dest, err)
	}
}

func toTemplate(d *diego.Schema, source string) *templateDiego {
	td := &templateDiego{
		Package:    "main", // Assuming main for now, will need to be configurable
		StructName: toGoName(d.EnvironmentPrefix) + "Vars",
		Source:     source,
		Flags:      make([]templateFlag, len(d.Flags)),
	}
	for i, f := range d.Flags {
		td.Flags[i] = templateFlag{
			Name:        f.Name,
			Description: f.Description,
			GoName:      toGoName(f.Name),
			JSONName:    f.Name,
			GoType:      f.Type,
			envPrefix:   d.EnvironmentPrefix,
		}
	}
	return td
}

type templateDiego struct {
	Package    string
	StructName string
	Source     string
	Flags      []templateFlag
}

type templateFlag struct {
	Name        string
	Description string
	GoName      string
	JSONName    string
	GoType      string
	envPrefix   string
}

func (f templateFlag) EnvLookup(errName string) string {
	envVar := strings.ToUpper(fmt.Sprintf("%s_%s", f.envPrefix, f.Name))
	switch f.GoType {
	case "string":
		return fmt.Sprintf(`env.LookupString(&base.%s, "%s")`, f.GoName, envVar)
	case "int":
		return fmt.Sprintf(`%s = errors.Join(%s, env.LookupInt(&base.%s, "%s"))`, errName, errName, f.GoName, envVar)
	case "bool":
		return fmt.Sprintf(`%s = errors.Join(%s, env.LookupBool(&base.%s, "%s"))`, errName, errName, f.GoName, envVar)
	}
	return ""
}

func (f templateFlag) FlagVar() string {
	switch f.GoType {
	case "string":
		return "StringVar"
	case "int":
		return "IntVar"
	case "bool":
		return "BoolVar"
	}
	return ""
}

func toGoName(s string) string {
	parts := strings.Split(s, "-")
	for i, part := range parts {
		parts[i] = strings.Title(part)
	}
	return strings.Join(parts, "")
}
