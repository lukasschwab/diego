package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
	"text/template"

	"github.com/lukasschwab/diego/internal/diego"
	"github.com/tailscale/hujson"
)

var (
	jsonTemplate   *template.Template
	structTemplate *template.Template
)

//go:generate diego -type=DiegoVars
type DiegoVars struct {
	// --json-file: relative path of the JSON file specifying command line args
	JsonFile string `json:"json-file"`
	// --struct-type: name of the struct specifying command line args
	StructType string `json:"struct-type"`
}

func init() {
	// NOTE: this always loads one unused template.
	var err error
	if jsonTemplate, err = template.New("diego-json").Parse(diego.JSONTemplate); err != nil {
		log.Fatalf("error parsing template: %v", err)
	}
	if structTemplate, err = template.New("diego-struct").Parse(diego.BaseTemplate); err != nil {
		log.Fatalf("error parsing native template: %v", err)
	}
}

func main() {
	vars := new(DiegoVars)
	if err := vars.Parse(os.Args[1:]); err != nil {
		log.Fatalf("Error parsing args: %v", err)
	}

	if vars.JsonFile != "" && vars.StructType != "" {
		log.Fatalf("--json-file and --struct-type are mutually exclusive options")
	}
	if vars.JsonFile == "" && vars.StructType == "" {
		log.Fatalf("Specify either --json-file or --struct-type")
	}

	var source Source
	{
		var err error
		if vars.StructType != "" {
			source, err = LoadStructSource(vars.StructType)
		} else {
			source, err = LoadJSONSource(vars.JsonFile)
		}
		if err != nil {
			log.Fatalf("Error loading schema source: %v", err)
		}
	}

	if prepared, err := source.PrepareSchema(); err != nil {
		log.Fatalf("Error transforming schema for template: %v", err)
	} else if err := generate(source.DestinationFilename(), prepared, source.Template()); err != nil {
		log.Fatalf("Error rendering template: %v", err)
	}
}

func generate(destFilename string, prepared *diego.TemplateSchema, template *template.Template) error {
	var generated bytes.Buffer
	if err := template.Execute(&generated, prepared); err != nil {
		return fmt.Errorf("error executing native template: %v", err)
	}
	formatted, err := format.Source(generated.Bytes())
	if err != nil {
		return fmt.Errorf("error formatting generated code: %v\n%s", err, generated.String())
	}
	if err := os.WriteFile(destFilename, formatted, 0644); err != nil {
		return fmt.Errorf("error writing generated code to %s: %v", destFilename, err)
	}
	return nil
}

type Source interface {
	Template() *template.Template
	DestinationFilename() string
	PrepareSchema() (*diego.TemplateSchema, error)
}

var (
	_ Source = JSONSource{}
	_ Source = StructSource{}
)

type JSONSource struct {
	filename string
	schema   *diego.Schema
}

func LoadJSONSource(filename string) (JSONSource, error) {
	d := new(diego.Schema)
	if jsonBytes, err := os.ReadFile(filename); err != nil {
		return JSONSource{}, fmt.Errorf("error reading source file: %v", err)
	} else if standardized, err := hujson.Standardize(jsonBytes); err != nil {
		return JSONSource{}, fmt.Errorf("error standardizing source JSON: %v", err)
	} else if err := json.Unmarshal(standardized, d); err != nil {
		return JSONSource{}, fmt.Errorf("error unmarshaling source JSON: %v", err)
	}
	return JSONSource{
		filename: filename,
		schema:   d,
	}, nil
}

func (s JSONSource) Template() *template.Template {
	return jsonTemplate
}

func (s JSONSource) DestinationFilename() string {
	// e.g. args.json → args.json.go
	return s.filename + ".go"
}

func (s JSONSource) PrepareSchema() (*diego.TemplateSchema, error) {
	prefix, err := diego.ValidatePrefix(s.schema.EnvironmentPrefix)
	if err != nil {
		return nil, err
	}
	td := &diego.TemplateSchema{
		Package:    "main", // Assuming main for now, will need to be configurable
		StructName: diego.BuildGoName(s.schema.EnvironmentPrefix) + "Vars",
		Source:     s.filename,
		Flags:      make([]diego.TemplateFlag, len(s.schema.Flags)),
		Prefix:     prefix,
	}
	for i, f := range s.schema.Flags {
		td.Flags[i] = diego.TemplateFlag{
			Name:        f.Name,
			Description: f.Description,
			GoType:      f.Type,
			Prefix:      prefix,
		}
	}
	return td, nil
}

type StructSource struct {
	goFile     string
	goPackage  string
	structType string
}

func LoadStructSource(structType string) (StructSource, error) {
	result := StructSource{structType: structType}
	if result.goFile = os.Getenv("GOFILE"); result.goFile == "" {
		return result, errors.New("GOFILE env var must be set in --struct-type mode")
	}
	if result.goPackage = os.Getenv("GOPACKAGE"); result.goPackage == "" {
		return result, errors.New("GOPACKAGE env var must be set in --struct-type mode")
	}
	return result, nil
}

func (s StructSource) Template() *template.Template {
	return structTemplate
}

func (s StructSource) DestinationFilename() string {
	// e.g. main.go → main_args.go
	return strings.TrimSuffix(s.goFile, ".go") + "_args.go"
}

func (s StructSource) PrepareSchema() (*diego.TemplateSchema, error) {
	templateSchema, err := diego.FromAst(s.goFile, s.structType)
	if err != nil {
		return nil, fmt.Errorf("error parsing gofile: %v", err)
	}
	return templateSchema, nil
}
